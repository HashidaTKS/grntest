#!/usr/bin/env ruby
#
# Copyright (C) 2012  Kouhei Sutou <kou@clear-code.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

require "English"
require "optparse"
require "pathname"
require "fileutils"
require "tempfile"

class GroongaTester
  attr_accessor :groonga, :diff, :diff_options
  def initialize
    @groonga = "groonga"
    detect_suitable_diff
    @failed_tests = []
    @reporter = Reporter.new(self)
  end

  def run(*targets)
    succeeded = true
    return succeeded if targets.empty?

    @reporter.start
    targets.each do |target|
      target_path = Pathname(target)
      next unless target_path.exist?
      if target_path.directory?
        Dir.glob(target_path + "**" + "*.test") do |target_file|
          succeeded = false unless run_test(Pathname(target_file))
        end
      else
        succeeded = false unless run_test(target_path)
      end
    end
    @reporter.finish
    succeeded
  end

  private
  def run_test(test_script_path)
    succeeded = true

    @reporter.start_test(test_script_path)
    actual_result = run_groonga_script(test_script_path)
    actual_result = normalize_result(actual_result)
    expected_result = read_expected_result(test_script_path)
    if expected_result
      if actual_result == expected_result
        @reporter.pass_test
      else
        @reporter.fail_test(expected_result, actual_result)
        succeeded = false
      end
    else
      @reporter.no_check_test(actual_result)
    end
    @reporter.finish_test

    succeeded
  end

  def run_groonga_script(script_path)
    result = ""
    create_temporary_directory do |directory_path|
      run_groonga(File.join(directory_path, "db")) do |io|
        result = execute_script(script_path, io)
        io.close_write
      end
    end
    result
  end

  def execute_script(script_path, io)
    result = ""
    loading = false
    script_path.open do |script_file|
      script_file.each_line do |line|
        case line
        when /\A\s*\z/
          next
        when /\A\s*\#/
          comment_content = $POSTMATCH
          case comment_content
          when /\A\s*include\s+/
            path = $POSTMATCH.strip
            next if path.empty?
            result << execute_script(Pathname(path), io)
          end
        else
          unless loading
            loading = true if load_command?(line)
          end
          result << line
          io.print(line)
          io.flush
          if loading
            if /\]$/ =~ line
              current_result = read_output(io)
              loading = false unless current_result.empty?
              result << current_result
            end
          else
            result << read_output(io)
          end
        end
      end
    end
    result
  end

  def load_command?(line)
    /\A\s*load\s*/ =~ line
  end

  def create_temporary_directory
    path = "tmp"
    FileUtils.rm_rf(path)
    FileUtils.mkdir_p(path)
    begin
      yield path
    ensure
      FileUtils.rm_rf(path)
    end
  end

  def run_groonga(db_path)
    IO.popen([@groonga, "-n", db_path], "r+") do |io|
      begin
        yield io
      ensure
        io.close unless io.closed?
      end
    end
  end

  def normalize_result(result)
    result.gsub(/^\[\[0,[\d\.e\-]+,[\d\.e\-]+\]/, "[[0,0.0,0.0]")
  end

  def read_output(io)
    output = ""
    first_timeout = 1
    timeout = first_timeout
    while IO.select([io], [], [], timeout)
      break if io.eof?
      output << io.readpartial(65535)
      timeout = 0
    end
    output
  end

  def read_expected_result(test_script_path)
    result_path_name = test_script_path.to_s.gsub(/\..+?\z/, ".result")
    result_path = Pathname(result_path_name)
    return nil unless result_path.exist?
    return nil if test_script_path == result_path
    result_path.open do |result_file|
      result_file.read
    end
  end

  def detect_suitable_diff
    if command_exist?("cut-diff")
      @diff = "cut-diff"
      @diff_options = []
    else
      @diff = "diff"
      @diff_options = ["-u"]
    end
  end

  def command_exist?(name)
    ENV["PATH"].split(File::PATH_SEPARATOR).each do |path|
      absolute_path = File.join(path, name)
      return true if File.executable?(absolute_path)
    end
    false
  end

  class Reporter
    def initialize(tester)
      @tester = tester
      @term_width = guess_term_width
      @current_column = 0
      @output = STDOUT
      @n_tests = 0
      @n_passed_tests = 0
      @failed_tests = []
    end

    def start
    end

    def start_test(test_script_path)
      @test_name = test_script_path.basename
      print("  #{@test_name}")
      @output.flush
    end

    def pass_test
      report_test_result("pass")
      @n_passed_tests += 1
    end

    def fail_test(expected, actual)
      report_test_result("fail")
      puts("=" * @term_width)
      report_diff(expected, actual)
      puts("=" * @term_width)
      @failed_tests << @test_name
    end

    def no_check_test(result)
      report_test_result("not checked")
      puts(result)
    end

    def finish_test
      @n_tests += 1
    end

    def finish
      puts
      puts("#{@n_tests} tests, " +
           "#{@n_passed_tests} passes, " +
           "#{@failed_tests.size} failures.")
      if @n_tests.zero?
        pass_ratio = 0
      else
        pass_ratio = @n_passed_tests / @n_tests.to_f
      end
      puts("%.2g%% passed." % pass_ratio)
    end

    private
    def print(message)
      @current_column += message.to_s.size
      @output.print(message)
    end

    def puts(*messages)
      @current_column = 0
      @output.puts(*messages)
    end

    def report_test_result(label)
      message = " [#{label}]"
      message = message.rjust(@term_width - @current_column) if @term_width > 0
      puts(message)
    end

    def report_diff(expected, actual)
      create_temporary_file("expected", expected) do |expected_file|
        create_temporary_file("actual", actual) do |actual_file|
          diff_options = @tester.diff_options.dup
          diff_options.concat(["--label", "(actual)", actual_file.path,
                               "--label", "(expected)", expected_file.path])
          system(@tester.diff, *diff_options)
        end
      end
    end

    def create_temporary_file(key, content)
      file = Tempfile.new("groonga-test-#{key}")
      file.print(content)
      file.close
      yield file
    end

    def guess_term_width
      Integer(ENV["COLUMNS"] || ENV["TERM_WIDTH"] || 79)
    rescue ArgumentError
      0
    end
  end
end

tester = GroongaTester.new

parser = OptionParser.new
parser.banner += " TEST_FILE_OR_DIRECTORY..."

parser.on("--groonga=GROONGA",
          "Use GROONGA as groonga command",
          "(#{tester.groonga})") do |groonga|
  tester.groonga = groonga
end

parser.on("--diff=DIFF",
          "Use DIFF as diff command",
          "(#{tester.diff})") do |diff|
  tester.diff = diff
  tester.diff_options.clear
end

diff_option_is_specified = false
parser.on("--diff-option=OPTION",
          "Use OPTION as diff command",
          "(#{tester.diff_options.join(' ')})") do |option|
  tester.diff_options.clear if diff_option_is_specified
  tester.diff_options << option
  diff_option_is_specified = true
end

targets = parser.parse!
exit(tester.run(*targets))
