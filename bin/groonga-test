#!/usr/bin/env ruby
#
# Copyright (C) 2012  Kouhei Sutou <kou@clear-code.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

require "English"
require "optparse"
require "pathname"
require "fileutils"
require "tempfile"
require "json"

class GroongaTester
  MAX_N_COLUMNS = 79

  attr_accessor :groonga, :diff, :diff_options, :max_n_columns
  def initialize
    @groonga = "groonga"
    detect_suitable_diff
    @failed_tests = []
    @max_n_columns = MAX_N_COLUMNS
    @reporter = Reporter.new(self)
  end

  def run(*targets)
    succeeded = true
    return succeeded if targets.empty?

    @reporter.start
    targets.each do |target|
      target_path = Pathname(target)
      next unless target_path.exist?
      if target_path.directory?
        Dir.glob(target_path + "**" + "*.test") do |target_file|
          succeeded = false unless run_test(Pathname(target_file))
        end
      else
        succeeded = false unless run_test(target_path)
      end
    end
    @reporter.finish
    succeeded
  end

  private
  def run_test(test_script_path)
    succeeded = true

    @reporter.start_test(test_script_path)
    actual_result = run_groonga_script(test_script_path)
    actual_result = normalize_result(actual_result)
    expected_result = read_expected_result(test_script_path)
    if expected_result
      if actual_result == expected_result
        @reporter.pass_test
      else
        @reporter.fail_test(expected_result, actual_result)
        succeeded = false
      end
    else
      @reporter.no_check_test(actual_result)
    end
    @reporter.finish_test

    succeeded
  end

  def run_groonga_script(script_path)
    create_temporary_directory do |directory_path|
      run_groonga(File.join(directory_path, "db")) do |io|
        execute_script(script_path, io)
      end
    end
  end

  def execute_script(script_path, io)
    executer = Executer.new(io)
    executer.execute(script_path)
  end

  def create_temporary_directory
    path = "tmp"
    FileUtils.rm_rf(path)
    FileUtils.mkdir_p(path)
    begin
      yield path
    ensure
      FileUtils.rm_rf(path)
    end
  end

  def run_groonga(db_path)
    IO.popen([@groonga, "-n", db_path], "r+") do |io|
      begin
        yield io
      ensure
        io.close unless io.closed?
      end
    end
  end

  def normalize_result(result)
    normalized_result = ""
    result.each do |tag, content|
      case tag
      when :input
        normalized_result << content
      when :output
        status, *values = JSON.parse(content)
        normalized_status = normalize_status(status)
        normalized_output_content = [normalized_status, *values]
        normalized_output = JSON.generate(normalized_output_content)
        if normalized_output.bytesize > @max_n_columns
          normalized_output = JSON.pretty_generate(normalized_output_content)
        end
        normalized_output.force_encoding("ASCII-8BIT")
        normalized_result << "#{normalized_output}\n"
      end
    end
    normalized_result
  end

  def normalize_status(status)
    return_code, started_time, elapsed_time, *rest = status
    if return_code.zero?
      [0, 0.0, 0.0]
    else
      message, bactrace = rest
      [[return_code, 0.0, 0.0], message]
    end
  end

  def read_expected_result(test_script_path)
    result_path_name = test_script_path.to_s.gsub(/\..+?\z/, ".result")
    result_path = Pathname(result_path_name)
    return nil unless result_path.exist?
    return nil if test_script_path == result_path
    result_path.open do |result_file|
      result_file.read
    end
  end

  def detect_suitable_diff
    if command_exist?("cut-diff")
      @diff = "cut-diff"
      @diff_options = ["--context-lines", "10"]
    else
      @diff = "diff"
      @diff_options = ["-u"]
    end
  end

  def command_exist?(name)
    ENV["PATH"].split(File::PATH_SEPARATOR).each do |path|
      absolute_path = File.join(path, name)
      return true if File.executable?(absolute_path)
    end
    false
  end

  class Executer
    def initialize(groonga)
      @groonga = groonga
    end

    def execute(script_path, result=[])
      @loading = false
      @pending_command = ""
      script_path.open("r:ascii-8bit") do |script_file|
        script_file.each_line do |line|
          if @loading
            execute_line_on_loading(line, result)
          else
            execute_line_with_continuation_line_support(line, result)
          end
        end
      end
      result
    end

    private
    def execute_line_on_loading(line, result)
      result << [:input, line]
      @groonga.print(line)
      @groonga.flush
      if /\]$/ =~ line
        current_result = read_output
        unless current_result.empty?
          @loading = false
          result << [:output, current_result]
        end
      end
    end

    def execute_line_with_continuation_line_support(line, result)
      if /\\$/ =~ line
        @pending_command << $PREMATCH
      else
        if @pending_command.empty?
          execute_line(line, result)
        else
          @pending_command << line
          execute_line(@pending_command, result)
          @pending_command = ""
        end
      end
    end

    def execute_line(line, result)
      case line
      when /\A\s*\z/
        # do nothing
      when /\A\s*\#/
        comment_content = $POSTMATCH
        execute_comment(comment_content, result)
      else
        execute_command(line, result)
      end
    end

    def execute_comment(content, result)
      case content
      when /\A\s*include\s+/
        path = $POSTMATCH.strip
        return if path.empty?
        execute_script(path, result)
      end
    end

    def execute_script(path, result)
      executer = self.class.new(@groonga)
      executer.execute(Pathname(path), result)
    end

    def execute_command(line, result)
      @loading = true if load_command?(line)
      result << [:input, line]
      @groonga.print(line)
      @groonga.flush
      unless @loading
        current_result = read_output
        result << [:output, current_result] unless current_result.empty?
      end
    end

    def load_command?(line)
      /\A\s*load\s*/ =~ line
    end

    def read_output
      output = ""
      first_timeout = 1
      timeout = first_timeout
      while IO.select([@groonga], [], [], timeout)
        break if @groonga.eof?
        output << @groonga.readpartial(65535)
        timeout = 0
      end
      output
    end
  end

  class Reporter
    def initialize(tester)
      @tester = tester
      @term_width = guess_term_width
      @current_column = 0
      @output = STDOUT
      @n_tests = 0
      @n_passed_tests = 0
      @failed_tests = []
    end

    def start
    end

    def start_test(test_script_path)
      @test_name = test_script_path.basename
      print("  #{@test_name}")
      @output.flush
    end

    def pass_test
      report_test_result("pass")
      @n_passed_tests += 1
    end

    def fail_test(expected, actual)
      report_test_result("fail")
      puts("=" * @term_width)
      report_diff(expected, actual)
      puts("=" * @term_width)
      @failed_tests << @test_name
    end

    def no_check_test(result)
      report_test_result("not checked")
      puts(result)
    end

    def finish_test
      @n_tests += 1
    end

    def finish
      puts
      puts("#{@n_tests} tests, " +
           "#{@n_passed_tests} passes, " +
           "#{@failed_tests.size} failures.")
      if @n_tests.zero?
        pass_ratio = 0
      else
        pass_ratio = @n_passed_tests / @n_tests.to_f
      end
      puts("%.2g%% passed." % pass_ratio)
    end

    private
    def print(message)
      @current_column += message.to_s.size
      @output.print(message)
    end

    def puts(*messages)
      @current_column = 0
      @output.puts(*messages)
    end

    def report_test_result(label)
      message = " [#{label}]"
      message = message.rjust(@term_width - @current_column) if @term_width > 0
      puts(message)
    end

    def report_diff(expected, actual)
      create_temporary_file("expected", expected) do |expected_file|
        create_temporary_file("actual", actual) do |actual_file|
          diff_options = @tester.diff_options.dup
          diff_options.concat(["--label", "(actual)", actual_file.path,
                               "--label", "(expected)", expected_file.path])
          system(@tester.diff, *diff_options)
        end
      end
    end

    def create_temporary_file(key, content)
      file = Tempfile.new("groonga-test-#{key}")
      file.print(content)
      file.close
      yield file
    end

    def guess_term_width
      Integer(ENV["COLUMNS"] || ENV["TERM_WIDTH"] || 79)
    rescue ArgumentError
      0
    end
  end
end

tester = GroongaTester.new

parser = OptionParser.new
parser.banner += " TEST_FILE_OR_DIRECTORY..."

parser.on("--groonga=GROONGA",
          "Use GROONGA as groonga command",
          "(#{tester.groonga})") do |groonga|
  tester.groonga = groonga
end

parser.on("--diff=DIFF",
          "Use DIFF as diff command",
          "(#{tester.diff})") do |diff|
  tester.diff = diff
  tester.diff_options.clear
end

diff_option_is_specified = false
parser.on("--diff-option=OPTION",
          "Use OPTION as diff command",
          "(#{tester.diff_options.join(' ')})") do |option|
  tester.diff_options.clear if diff_option_is_specified
  tester.diff_options << option
  diff_option_is_specified = true
end

targets = parser.parse!
exit(tester.run(*targets))
